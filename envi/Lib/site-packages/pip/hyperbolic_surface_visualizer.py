import pygame
import numpy as np
import itertools
from matplotlib.path import Path

WIDTH, HEIGHT = 800, 600
SCALE = 100
CENTER = (WIDTH // 2, HEIGHT - 50)

base_input = "1+1j"
active_input = False
base_point = complex(1, 1)

def parse_input(text):
    transformations = []
    for line in text.strip().split("\n"):
        try:
            a, b, c, d = map(float, line.split())
            if abs(a * d - b * c - 1) > 1e-6:
                continue
            transformations.append((a, b, c, d))
        except:
            continue
    return transformations

def matrix_mult(g1, g2):
    a1, b1, c1, d1 = g1
    a2, b2, c2, d2 = g2
    a = a2 * a1 + b2 * c1
    b = a2 * b1 + b2 * d1
    c = c2 * a1 + d2 * c1
    d = c2 * b1 + d2 * d1
    return (a, b, c, d)

def generate_group_words(generators, depth=1):
    words = set()
    queue = [(1, 0, 0, 1)]  # identity matrix

    for _ in range(depth):
        new_queue = []
        for g in queue:
            for h in generators:
                gh = matrix_mult(g, h)
                # Normalize so determinant ~ 1
                det = gh[0] * gh[3] - gh[1] * gh[2]
                if abs(det - 1) > 1e-6:
                    continue
                words.add(gh)
                new_queue.append(gh)
        queue = new_queue
    return list(words)

def mobius_transform(a, b, c, d, z):
    return (a * z + b) / (c * z + d)

def invert_matrix(g):
    a, b, c, d = g
    return (d, -b, -c, a)

def complex_to_screen(z):
    x = CENTER[0] + z.real * SCALE
    y = CENTER[1] - z.imag * SCALE
    return int(x), int(y)

def draw_geodesic(screen, z1, z2, color, width=2, steps=100):
    # Skip vertical line case
    if abs(z1.real - z2.real) < 1e-6:
        x = CENTER[0] + z1.real * SCALE
        y1 = CENTER[1] - z1.imag * SCALE
        y2 = CENTER[1] - z2.imag * SCALE
        pygame.draw.line(screen, color, (x, y1), (x, y2), width)
        return

    # Find center of circle on real axis
    x1, y1 = z1.real, z1.imag
    x2, y2 = z2.real, z2.imag

    # Midpoint and radius via perpendicular bisector
    a = x1 - x2
    b = y1 - y2
    A = x1**2 + y1**2
    B = x2**2 + y2**2
    denom = 2 * (x1*y2 - x2*y1)

    if abs(denom) < 1e-8:
        return  # Avoid division by zero in degenerate case

    cx = ((A * y2 - B * y1) / denom)
    cy = 0
    r = abs(complex(x1 - cx, y1))

    # Draw semicircle from z1 to z2 counter-clockwise
    theta1 = np.angle(complex(x1 - cx, y1))
    theta2 = np.angle(complex(x2 - cx, y2))

    if theta2 < theta1:
        theta1, theta2 = theta2, theta1

    points = []
    for t in np.linspace(theta1, theta2, steps):
        x = cx + r * np.cos(t)
        y = r * np.sin(t)
        sx, sy = complex_to_screen(complex(x, y))
        points.append((sx, sy))

    if len(points) >= 2:
        pygame.draw.lines(screen, color, False, points, width)
        
def compute_dirichlet_polygon(base_point, images):
    # Sort by angle around base_point
    def angle(z):
        return np.angle(z - base_point)

    sorted_points = sorted(images, key=angle)
    return sorted_points

def fill_dirichlet_polygon(screen, base_point, images, color=(200, 200, 255)):
    points = compute_dirichlet_polygon(base_point, images)
    screen_points = [complex_to_screen(z) for z in points]
    if len(screen_points) >= 3:
        pygame.draw.polygon(screen, color, screen_points)

def main():
    global base_input, active_input, base_point

    pygame.init()
    screen = pygame.display.set_mode((WIDTH, HEIGHT))
    pygame.display.set_caption("Dirichlet Fundamental Domain")

    input_text = """1 0 -1 1"""
    generators = parse_input(input_text)
    generators_with_inverses = generators + [invert_matrix(g) for g in generators]

    input_box = pygame.Rect(20, 20, 160, 30)
    font = pygame.font.SysFont("Arial", 18)

    clock = pygame.time.Clock()
    running = True
    while running:
        screen.fill((255, 255, 255))

        # Draw real (x) axis
        pygame.draw.line(screen, (0, 0, 0), (0, CENTER[1]), (WIDTH, CENTER[1]), 2)

        # Draw imaginary (y) axis
        pygame.draw.line(screen, (0, 0, 0), (CENTER[0], 0), (CENTER[0], HEIGHT), 2)

        # Font for coordinates
        font = pygame.font.SysFont("Arial", 14)

        # Tick marks and labels
        for x in range(-5, 6):
            if x == 0:
                continue
            screen_x = CENTER[0] + x * SCALE
            pygame.draw.line(screen, (0, 0, 0), (screen_x, CENTER[1] - 5), (screen_x, CENTER[1] + 5))
            label = font.render(str(x), True, (0, 0, 0))
            screen.blit(label, (screen_x - 8, CENTER[1] + 8))

        for y in range(1, 6):
            screen_y = CENTER[1] - y * SCALE
            pygame.draw.line(screen, (0, 0, 0), (CENTER[0] - 5, screen_y), (CENTER[0] + 5, screen_y))
            label = font.render(str(y), True, (0, 0, 0))
            screen.blit(label, (CENTER[0] + 8, screen_y - 8))

        # Draw text input
        pygame.draw.rect(screen, (255, 255, 255), input_box)
        pygame.draw.rect(screen, (0, 0, 0), input_box, 2)
        txt_surface = font.render(base_input, True, (0, 0, 0))
        screen.blit(txt_surface, (input_box.x + 5, input_box.y + 5))
        label = font.render("Base point zâ‚€:", True, (0, 0, 0))
        screen.blit(label, (20, 0))

        # Draw base point
        pygame.draw.circle(screen, (0, 0, 255), complex_to_screen(base_point), 5)

        words = generate_group_words(generators_with_inverses, depth=10)

        images = [mobius_transform(a, b, c, d, base_point) for a, b, c, d in words]
        fill_dirichlet_polygon(screen, base_point, images)

        for image in images:
            draw_geodesic(screen, base_point, image, (255, 0, 0))
        for a, b, c, d in words:
            image = mobius_transform(a, b, c, d, base_point)
            draw_geodesic(screen, base_point, image, (255, 0, 0))

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if input_box.collidepoint(event.pos):
                    active_input = True
                else:
                    active_input = False
            elif event.type == pygame.KEYDOWN and active_input:
                if event.key == pygame.K_RETURN:
                    try:
                        base_point = complex(base_input)
                    except:
                        pass
                elif event.key == pygame.K_BACKSPACE:
                    base_input = base_input[:-1]
                else:
                    base_input += event.unicode

        pygame.display.flip()
        clock.tick(30)

    pygame.quit()

if __name__ == "__main__":
    main()


